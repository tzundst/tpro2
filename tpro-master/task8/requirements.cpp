/*
Любые указанные файлы не совпадают, если иное не оговороено
Большое количество одноименных файлов,отличающихся номером, нужно для того, чтобы исключить возможную перезапись результатов

Это не полноценный набор, а руководство к действию

Необходимые входные данные: 
f1_in_correct1.txt - корректный файл с одной текстовой строкой
f1_in_double1.txt - файл являющийся конкатинацией (склейкой) дважды файла f1_in_correct1.txt
f1_in_correct3.txt - корректный файл с несколькими (тремя) текстовыми строками
f1_in_double3.txt - файл являющийся конкатинацией (склейкой) дважды файла f1_in_correct3.txt
f1_in_empty.txt - пустой файл
f1_in_null.txt - такого файла не существует
f1_N - правильное число входных строк

f2_in_correct1.txt - корректный файл с числами, больше одного числа в строке, больше одной строки, половина файлов через ".", половина через ",", кроме того есть числа без дробной части
f2_in_correct2.txt - корректный файл с числами, одна строка, одно число
f2_in_correct3.txt - корректный файл с нулем
f2_in_incorrect1.txt - файл с текстом или нарушением формата
f2_in_incorrect2.txt - файл с хотя бы одним отрицательным числом, общая сумма положительна
f2_in_incorrect3.txt - файл с несколькими отрицательными числами, сумма которых меньше нуля
f2_in_empty.txt - пустой файл
f2_in_null.txt - такого файла не существует
f2_N1 - известная сумма для f2_in_correct1.txt
f2_N2 - известная сумма для f2_in_correct2.txt

f3_in_correct.txt - текстовый файл с каким-то текстом в несколько строк (удобочитаемым).
f3_in_empty.txt - пустой файл
f3_in_null.txt - такого файла не существует
key1 - текстовый ключ для шифрования
key2 - текстовый ключ для шифрования
f3_N - известный размер файла f3_in_correct.txt

Выходные данные:
Отдельные файлы будут создаваться автоматически, все файлы должны быть в репозитории по окончанию тестирования
new_f1_out_correct1.txt - правильный файл (не существует перед вызовом функции)
new_f1_out_correct2.txt - правильный файл (не существует перед вызовом функции)
new_f1_out_correct3.txt - правильный файл (не существует перед вызовом функции)
new_f1_out_correct4.txt - правильный файл (не существует перед вызовом функции)
new_f1_out_correct5.txt - правильный файл (не существует перед вызовом функции)
f1_out_empty.txt - пустой файл (существует)
f1_out_empty_source.txt (из этого файла формируется f1_out_empty.txt перед началом тестирования)
f1_out_incorrect.txt - несуществующий файл с несуществующим путем или директория
new_f3_out_correct1.txt - правильный файл (не существует перед вызовом функции) - будет использоваться для первого шифрования
new_f3_out_correct2.txt - правильный файл (не существует перед вызовом функции) - будет использоваться для второго шифрования
new_f3_out_correct3.txt - правильный файл (не существует перед вызовом функции) - будет использоваться для проверки перезаписи
new_f3_out_correct4.txt - правильный файл (не существует перед вызовом функции)
new_f3_out_correct5.txt - правильный файл (не существует перед вызовом функции)
new_f3_out_correct6.txt - правильный файл (не существует перед вызовом функции)
f3_out_correct_exist1.txt - правильный файл (существует перед вызовом функции) - будет использоваться для проверки перезаписи
f3_out_correct_exist2.txt - правильный файл совпадает с одноименным 1 (существует перед вызовом функции) - будет использоваться для проверки перезаписи
f3_out_correct_exist1_source.txt (из этого файла формируется f3_out_correct_exist1.txt перед началом тестирования)
f3_out_correct_exist2_source.txt (из этого файла формируется f3_out_correct_exist2.txt перед началом тестирования)
f3_out_empty.txt - пустой файл (существует)
f3_out_empty_source.txt (из этого файла формируется f3_out_empty.txt перед началом тестирования)
f3_out_incorrect.txt - несуществующий файл с несуществующим путем или директория


Функции:
1.
res=FUNC1(in,out) - функция построчного копирования файла in в файл out.
res:
положительное число >=0 - число скопированых строк
-1 - ошибка открытия входного файла
-2 - ошибка открытия выходного файла

2.
res=FUNC2(in) - функция суммирования положительных чисел из файла in
res:
положительное число >=0 - сумма чисел из файла
-1 - ошибка открытия входного файла
-3 - ошибка содержимого файла  //-3 так как -2 зарезервировано для ошибки выходного файла

3.
res=FUNC3(in,out,key) - функция шифрования файла in в файл out ключем (строкой) key
res:
положительное число >=0 - число зашифрованных байт
-1 - ошибка открытия входного файла
-2 - ошибка открытия выходного файла
-4 - ошибка ключа //аналогично почему не -3 (зарезервировано)

4.
res=DIFF(in,out) - функция побайтового сравнения файлов in и out
res:
0 - файлы не отличаются
положительное число >0 - первый байт с которого они отличаются
-1 - ошибка открытия входного файла
-2 - ошибка открытия выходного файла


*/
/********************************************************************************************************************/
TEST_CASE("diff","[diff]") //проверка функции DIFF, CHECK и REQUIRE используются по разному просто для примера
{
	CHECK(DIFF("f1_in_correct.txt","f1_in_correct.txt")==0) //сравнение с самим собой  //тест с корректными данными
	CHECK(DIFF("f1_in_correct.txt","f2_in_correct1.txt")>0) //разные файлы             //тест с корректными данными
	CHECK(DIFF("f1_in_correct.txt","f1_in_empty.txt")>0)    //один файл пустой         //тест с пустыми данными (в файле)
	REQUIRE(DIFF("f1_in_correct.txt","f1_in_null.txt")==-2)   //нет файла                //тест с неверными данными
	REQUIRE(DIFF("f1_in_null.txt","f1_in_correct.txt")==-1)   //нет файла                //тест с неверными данными
	REQUIRE(DIFF("f1_in_correct.txt","")==-2)                 //нет имени файла          //тест с пустыми данными (в имени файла)
	REQUIRE(DIFF("","f1_in_correct.txt")==-1)                 //нет имени файла          //тест с пустыми данными (в имени файла)
}
/*********************************************************************************************************************/
/*
Функция 1.
Анализ требований (что нужно проверить)
- функция возвращает количество скопированных строк или ошибку
- входной файл является текстовым
- выходной файл создается или дописывается

Пустые тесты
- входной файл существует, но пустой
- имя входного файла = ""
- имя выходного файла = ""

Неправильные тесты
- входной файл бинарный 
- указывается несуществующее имя входного файла
- указывается имя существующей директории, вместо имени файла (входного или выходного - 2 теста)

Правильные тесты
- файл с одной строкой
- файл с несколькими строками
- файл оканчивающийся пустой строкой (\nEOF) и нет (EOF), может при копировании + 1 байт сделать (\nEOF) и (\nEOF), соответственно
- проверить что выходной файл не существует изначально
- проверить совпадение выходного файла и входного после копирования
- проверить дозапись путем двойного копирования входного файла в выходной и сравнения с заранее подготвленным двойным файлом
- проверить, что исхный файл не поменялся
*/

//f1_in_correct1 - 1 строка
//f1_in_correct1-copy - дубликат файла с 1 строкой
//f1_in_double1 - конкатинация 1 файла (f1_in_correct1+f1_in_correct1) для проверки дописывания
//f1_in_correct3 - файл с тремя строками, последняя строка кончатеся на EOF, а не \n
//f1_in_correct3-copy
//f1_in_double3 - конкатинация файла с тремя строками (f1_in_correct3+f1_in_correct3) для проверки дописывания - особенность: файл будет из 5 строк, потому что две строки в средеине склеятся, ведь в исходном файле последняя строка кончается на EOF, без \n
//f1_in_empty - пустой существующий файл
//f1_out_empty - пустой существующий файл проверки дозаписи
//f1_out_null - выходной не существующий файл

//Пример реализации всех правильных тестов в едином TEST_CASE
//Перед запуском, восстановить исходные данные для тестирования

TEST_CASE("func1_full",[func1][correct_test])
{
	//проверка создания файла и копирования однострочного файла
	CHECK(DIFF(f1_in_correct1,f1_out_null) == -2)  //выходной файл не существует
	REQUIRE_NOTHROW(res1=FUNC1(f1_in_correct1,f1_out_null))  //вызов функции для однострочной функции - REQUIRE потому что если будет исключение - все остальные тесты бессмысленны
	CHECK(res1 >= 0) // проверка отсутствия ошибок, функция отработала, но результат пожет быть неправильный
	CHECK(res1 == 1) //скопирована 1 строка 
	CHECK(DIFF(f1_in_correct1,f1_out_null)==0)  //выходной и входной файл совпадают, значит создан
	CHECK(DIFF(f1_in_correct1,f1_in_correct1-copy)==0)  //входной файл не изменился, совпадает с исходной копией
	
	//Проверка дописывания однострочной функции
	REQUIRE_NOTHROW(res2=FUNC1(f1_in_correct1,f1_out_null))  //вызов функции (должно быть дописывание)
	CHECK(res2 >= 0) // проверка отсутствия ошибок, функция отработала, но результат пожет быть неправильный
	CHECK(res2 == 1) //скопирована 1 строка 
	CHECK(DIFF(f1_in_correct1,f1_out_null)>0)  //выходной и входной файл не совпадают (можно не проводить такой тест)
	CHECK(DIFF(f1_in_double1,f1_out_null) == 0) //выходной файл совпадает с двойным исходным файлом
	CHECK(DIFF(f1_in_correct1,f1_in_correct1-copy)==0)  //входной файл не изменился, совпадает с исходной копией

	//Проверка дописывания в пустой файл и копирования трехстрочного файла
	CHECK(DIFF(f1_in_empty,f1_out_empty) == 0)  //выходной файл  существует и пустой
	REQUIRE_NOTHROW(res3=FUNC1(f1_in_correct3,f1_out_empty))  //вызов функции для трехстрочного файла
	CHECK(res3 >= 0) // проверка отсутствия ошибок, функция отработала, но результат пожет быть неправильный
	CHECK(res3 == 3) //скопировано 3 строки
	CHECK(DIFF(f1_in_correct3,f1_out_empty)==0)  //выходной и входной файл совпадают, значит дописан пустой файл правильно
	CHECK(DIFF(f1_in_correct3,f1_in_correct3-copy)==0)  //входной файл не изменился, совпадает с исходной копией
	
	//Проверка дописывания трехстрочной функции
	REQUIRE_NOTHROW(res4=FUNC1(f1_in_correct3,f1_out_empty))  //вызов функции (должно быть дописывание)
	CHECK(res4 >= 0) // проверка отсутствия ошибок, функция отработала, но результат пожет быть неправильный
	CHECK(res4 == 3) //скопировано 3 строки
	CHECK(DIFF(f1_in_correct3,f1_out_empty)>0)  //выходной и входной файл не совпадают (можно не проводить такой тест)
	CHECK(DIFF(f1_in_double3,f1_out_empty) == 0) //выходной файл совпадает с двойным исходным файлом
	CHECK(DIFF(f1_in_correct3,f1_in_correct3-copy)==0)  //входной файл не изменился, совпадает с исходной копией

}


/*
Функция 2.
Анализ требований (что нужно проверять)
- функция суммирует положительные числа с плавающей точкой
- функция возвращает сумму чисел или код ошибки
- числа разделяются пробелом или переводом строки
- дробная часть отделяется точкой или запятой
- файл текстовый и содержит только числа в указанном формате

Пустые тесты
- входной файл существует, но пустой
- имя входного файла = ""

Неправильные тесты
- файл с текстом или нарушением формата
- файл с хотя бы одним отрицательным числом, общая сумма положительна
- файл с несколькими отрицательными числами, сумма которых меньше нуля

Правильные тесты
- корректный файл с числами, больше одного числа в строке, больше одной строки, половина файлов через ".", половина через ",", кроме того есть числа без дробной части
- корректный файл с числами, одна строка, одно число
- корректный файл с нулем 0
- корректный файл с нулем 0.0
- корректный файл с двойным переводом строк и двумя пробелами
- проверка, что исходный файл не поменялся


Функция 3.
Анализ требований (что нужно проверять)
- функция работает по XOR
- функция возвращает число зашифрованных байт или код ошибки
- выходной файл или создается или перезаписывается

Пустые тесты
- входной файл существует, но пустой, корретная работа
- имя входного файла = "", выходной файл должен создаться, но быть пустым
- имя выходного файла = "", функция возвращает или код ошибки или правильное количество байт, но файла нет
- пустой ключ шифрования = "", выдается ошибка, если ошибка не выдалась и файл совпадает с исходным, то шифрование работает правильно, просто не проводится проверка пустоты ключа

Неправильные тесты
- указывается несуществующее имя файла (входной, так как выходной должен создаться)
- указывается имя существующей директории, вместо имени файла (два файла - два теста)

Правильные тесты
- текстовый файл с каким-то текстом в несколько строк (удобочитаемым) проверка однократного шифрования - должен быть подготовлен шифрованный файл-эталон, можно чтобы сосед поделился, заодно друг-друга проверить.
- текстовый файл с каким-то текстом в несколько строк (удобочитаемым) проверка двукратного шифрования, файл не должен измениться
- проверить что выходной файл не существует изначально
- проверка на перезапись
- проверка, что исходный файл не поменялся


Общее

Перед началом тестирования удалить все файлы с данными - исходные (так как могут быть изменены программой) и создаваемые  и загрузить корректные файлы с данными (начальное состояние)
Результат сразу не проверять, записывать в переменную, потом ее анализировать, саму функцию при этом проверять на отсутствеи исключений
Сравнивать результат с требуемым
Сравнивать создержимое файла с требуемым
Перед запуском функции, создающей файлы (1 или 3) проверять выходной файл (в зависимости от теста, или пустой, или несуществует, или содержит конкретную информацию)
Проверять, что исходный файл не поменялся - программа могла его модифицировать, для этого иметь эталонную копию, с которой можно сравниться вначале тестирования

Правильные тесты можно объединять в единый TEST_CASE, сформировав некоторый сценарий, неправильные - каждый в отдельном TEST_CASE, пустые - тоже каждый в отдельном TEST_CASE
*/
